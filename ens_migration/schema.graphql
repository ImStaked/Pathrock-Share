type Domain @entity {
  "The namehash of the name"
  id: ID!
  "The human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)"
  name: String
  "The human readable label name (imported from CSV), if known"
  labelName: String
  "keccak256(labelName)"
  labelhash: Bytes
  "The namehash (id) of the parent name"
  parent: Domain
  "Can count domains from length of array"
  subdomains: [Domain!]! @derivedFrom(field: "parent")
  "The number of subdomains"
  subdomainCount: Int!
  "Address logged from current resolver, if any"
  resolvedAddress: Account

  "The resolver that controls the domain's settings"
  resolver: Resolver
  "The time-to-live (TTL) value of the domain's records"
  ttl: BigInt

  "Indicates whether the domain has been migrated to a new registrar"
  isMigrated: Boolean!
  "The time when the domain was created"
  createdAt: BigInt!

  "The account that owns the domain"
  owner: Account!
  "The account that owns the ERC721 NFT for the domain"
  registrant: Account
  "The account that owns the wrapped domain"
  wrappedOwner: Account

  "The expiry date for the domain, from either the registration, or the wrapped domain if PCC is burned"
  expiryDate: BigInt

}

type DomainEvent @entity {
  "The unique identifier of the event"
  id: ID!
  "The domain name associated with the event"
  domain: Domain!
  "The block number at which the event occurred"
  blockNumber: Int!
  "The transaction hash of the transaction that triggered the event"
  transactionID: Bytes!
}


type Registration @entity{
  "The unique identifier of the registration"
  id: ID!
  "The domain name associated with the registration"
  domain: Domain!
  "The registration date of the domain"
  registrationDate: BigInt!
  "The expiry date of the domain"
  expiryDate: BigInt!
  "The cost associated with the domain registration"
  cost: BigInt
  "The account that registered the domain"
  registrant: Account!
  "The human-readable label name associated with the domain registration"
  labelName: String
  "The events associated with the domain registration"
  events: [RegistrationEvent!]! @derivedFrom(field: "registration")
}

type RegistrationEvent @entity {
  "The unique identifier of the registration event"
  id: ID!
  "The registration associated with the event"
  registration: Registration!
  "The block number of the event"
  blockNumber: Int!
  "The transaction ID associated with the event"
  transactionID: Bytes!
}

type WrappedDomain @entity {
  "unique identifier for each instance of the WrappedDomain entity"
  id: ID!
  "The domain that is wrapped by this WrappedDomain"
  domain: Domain!
  "The expiry date of the wrapped domain"
  expiryDate: BigInt!
  "The number of fuses remaining on the wrapped domain"
  fuses: Int!
  "The account that owns this WrappedDomain"
  owner: Account!
  "The name of the wrapped domain"
  name: String
}

type Account @entity {
  "The unique identifier for the account"
  id: ID!
  "The domains owned by the account"
  domains: [Domain!]! @derivedFrom(field: "owner")
  "The WrappedDomains owned by the account"
  wrappedDomains: [WrappedDomain!] @derivedFrom(field: "owner")
  "The Registrations made by the account"
  registrations: [Registration!] @derivedFrom(field: "registrant")
}

type Resolver @entity {
  "The unique identifier for this resolver, which is a concatenation of the resolver address and the domain namehash"
  id: ID!
  "The domain that this resolver is associated with"
  domain: Domain
  "The address of the resolver contract"
  address: Bytes!
  "The current value of the 'addr' record for this resolver, as determined by the associated events"
  addr: Account
  "The content hash for this resolver, in binary format"
  contentHash: Bytes
  "The set of observed text record keys for this resolver"
  texts: [String!]
  "The events associated with this resolver"
  events: [ResolverEvent!]! @derivedFrom(field: "resolver")
}

type ResolverEvent @entity {
  "Concatenation of block number and log ID"
  id: ID!
  "Used to derive relationships to Resolvers"
  resolver: Resolver!
  "The block number that the event occurred on"
  blockNumber: Int!
  "The transaction hash of the event"
  transactionID: Bytes!
}

